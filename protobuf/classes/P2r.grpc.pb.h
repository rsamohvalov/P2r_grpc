// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: P2r.proto
#ifndef GRPC_P2r_2eproto__INCLUDED
#define GRPC_P2r_2eproto__INCLUDED

#include "P2r.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace p2r {

class P2R final {
 public:
  static constexpr char const* service_full_name() {
    return "p2r.P2R";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status P2rSetupConnection(::grpc::ClientContext* context, const ::p2r::SetupRequest& request, ::p2r::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>> AsyncP2rSetupConnection(::grpc::ClientContext* context, const ::p2r::SetupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>>(AsyncP2rSetupConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>> PrepareAsyncP2rSetupConnection(::grpc::ClientContext* context, const ::p2r::SetupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>>(PrepareAsyncP2rSetupConnectionRaw(context, request, cq));
    }
    virtual ::grpc::Status P2rReleaseConnection(::grpc::ClientContext* context, const ::p2r::ReleaseRequest& request, ::p2r::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>> AsyncP2rReleaseConnection(::grpc::ClientContext* context, const ::p2r::ReleaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>>(AsyncP2rReleaseConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>> PrepareAsyncP2rReleaseConnection(::grpc::ClientContext* context, const ::p2r::ReleaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>>(PrepareAsyncP2rReleaseConnectionRaw(context, request, cq));
    }
    virtual ::grpc::Status P2rTerminateWarning(::grpc::ClientContext* context, const ::p2r::TerminateWarning& request, ::p2r::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>> AsyncP2rTerminateWarning(::grpc::ClientContext* context, const ::p2r::TerminateWarning& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>>(AsyncP2rTerminateWarningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>> PrepareAsyncP2rTerminateWarning(::grpc::ClientContext* context, const ::p2r::TerminateWarning& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>>(PrepareAsyncP2rTerminateWarningRaw(context, request, cq));
    }
    virtual ::grpc::Status P2rTerminateWarningCancel(::grpc::ClientContext* context, const ::p2r::TerminateCancel& request, ::p2r::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>> AsyncP2rTerminateWarningCancel(::grpc::ClientContext* context, const ::p2r::TerminateCancel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>>(AsyncP2rTerminateWarningCancelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>> PrepareAsyncP2rTerminateWarningCancel(::grpc::ClientContext* context, const ::p2r::TerminateCancel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>>(PrepareAsyncP2rTerminateWarningCancelRaw(context, request, cq));
    }
    virtual ::grpc::Status P2rRestoreWarning(::grpc::ClientContext* context, const ::p2r::RestoreWarning& request, ::p2r::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>> AsyncP2rRestoreWarning(::grpc::ClientContext* context, const ::p2r::RestoreWarning& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>>(AsyncP2rRestoreWarningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>> PrepareAsyncP2rRestoreWarning(::grpc::ClientContext* context, const ::p2r::RestoreWarning& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>>(PrepareAsyncP2rRestoreWarningRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void P2rSetupConnection(::grpc::ClientContext* context, const ::p2r::SetupRequest* request, ::p2r::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void P2rSetupConnection(::grpc::ClientContext* context, const ::p2r::SetupRequest* request, ::p2r::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void P2rReleaseConnection(::grpc::ClientContext* context, const ::p2r::ReleaseRequest* request, ::p2r::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void P2rReleaseConnection(::grpc::ClientContext* context, const ::p2r::ReleaseRequest* request, ::p2r::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void P2rTerminateWarning(::grpc::ClientContext* context, const ::p2r::TerminateWarning* request, ::p2r::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void P2rTerminateWarning(::grpc::ClientContext* context, const ::p2r::TerminateWarning* request, ::p2r::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void P2rTerminateWarningCancel(::grpc::ClientContext* context, const ::p2r::TerminateCancel* request, ::p2r::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void P2rTerminateWarningCancel(::grpc::ClientContext* context, const ::p2r::TerminateCancel* request, ::p2r::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void P2rRestoreWarning(::grpc::ClientContext* context, const ::p2r::RestoreWarning* request, ::p2r::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void P2rRestoreWarning(::grpc::ClientContext* context, const ::p2r::RestoreWarning* request, ::p2r::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>* AsyncP2rSetupConnectionRaw(::grpc::ClientContext* context, const ::p2r::SetupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>* PrepareAsyncP2rSetupConnectionRaw(::grpc::ClientContext* context, const ::p2r::SetupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>* AsyncP2rReleaseConnectionRaw(::grpc::ClientContext* context, const ::p2r::ReleaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>* PrepareAsyncP2rReleaseConnectionRaw(::grpc::ClientContext* context, const ::p2r::ReleaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>* AsyncP2rTerminateWarningRaw(::grpc::ClientContext* context, const ::p2r::TerminateWarning& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>* PrepareAsyncP2rTerminateWarningRaw(::grpc::ClientContext* context, const ::p2r::TerminateWarning& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>* AsyncP2rTerminateWarningCancelRaw(::grpc::ClientContext* context, const ::p2r::TerminateCancel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>* PrepareAsyncP2rTerminateWarningCancelRaw(::grpc::ClientContext* context, const ::p2r::TerminateCancel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>* AsyncP2rRestoreWarningRaw(::grpc::ClientContext* context, const ::p2r::RestoreWarning& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::p2r::Response>* PrepareAsyncP2rRestoreWarningRaw(::grpc::ClientContext* context, const ::p2r::RestoreWarning& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status P2rSetupConnection(::grpc::ClientContext* context, const ::p2r::SetupRequest& request, ::p2r::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>> AsyncP2rSetupConnection(::grpc::ClientContext* context, const ::p2r::SetupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>>(AsyncP2rSetupConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>> PrepareAsyncP2rSetupConnection(::grpc::ClientContext* context, const ::p2r::SetupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>>(PrepareAsyncP2rSetupConnectionRaw(context, request, cq));
    }
    ::grpc::Status P2rReleaseConnection(::grpc::ClientContext* context, const ::p2r::ReleaseRequest& request, ::p2r::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>> AsyncP2rReleaseConnection(::grpc::ClientContext* context, const ::p2r::ReleaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>>(AsyncP2rReleaseConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>> PrepareAsyncP2rReleaseConnection(::grpc::ClientContext* context, const ::p2r::ReleaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>>(PrepareAsyncP2rReleaseConnectionRaw(context, request, cq));
    }
    ::grpc::Status P2rTerminateWarning(::grpc::ClientContext* context, const ::p2r::TerminateWarning& request, ::p2r::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>> AsyncP2rTerminateWarning(::grpc::ClientContext* context, const ::p2r::TerminateWarning& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>>(AsyncP2rTerminateWarningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>> PrepareAsyncP2rTerminateWarning(::grpc::ClientContext* context, const ::p2r::TerminateWarning& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>>(PrepareAsyncP2rTerminateWarningRaw(context, request, cq));
    }
    ::grpc::Status P2rTerminateWarningCancel(::grpc::ClientContext* context, const ::p2r::TerminateCancel& request, ::p2r::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>> AsyncP2rTerminateWarningCancel(::grpc::ClientContext* context, const ::p2r::TerminateCancel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>>(AsyncP2rTerminateWarningCancelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>> PrepareAsyncP2rTerminateWarningCancel(::grpc::ClientContext* context, const ::p2r::TerminateCancel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>>(PrepareAsyncP2rTerminateWarningCancelRaw(context, request, cq));
    }
    ::grpc::Status P2rRestoreWarning(::grpc::ClientContext* context, const ::p2r::RestoreWarning& request, ::p2r::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>> AsyncP2rRestoreWarning(::grpc::ClientContext* context, const ::p2r::RestoreWarning& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>>(AsyncP2rRestoreWarningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>> PrepareAsyncP2rRestoreWarning(::grpc::ClientContext* context, const ::p2r::RestoreWarning& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::p2r::Response>>(PrepareAsyncP2rRestoreWarningRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void P2rSetupConnection(::grpc::ClientContext* context, const ::p2r::SetupRequest* request, ::p2r::Response* response, std::function<void(::grpc::Status)>) override;
      void P2rSetupConnection(::grpc::ClientContext* context, const ::p2r::SetupRequest* request, ::p2r::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void P2rReleaseConnection(::grpc::ClientContext* context, const ::p2r::ReleaseRequest* request, ::p2r::Response* response, std::function<void(::grpc::Status)>) override;
      void P2rReleaseConnection(::grpc::ClientContext* context, const ::p2r::ReleaseRequest* request, ::p2r::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void P2rTerminateWarning(::grpc::ClientContext* context, const ::p2r::TerminateWarning* request, ::p2r::Response* response, std::function<void(::grpc::Status)>) override;
      void P2rTerminateWarning(::grpc::ClientContext* context, const ::p2r::TerminateWarning* request, ::p2r::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void P2rTerminateWarningCancel(::grpc::ClientContext* context, const ::p2r::TerminateCancel* request, ::p2r::Response* response, std::function<void(::grpc::Status)>) override;
      void P2rTerminateWarningCancel(::grpc::ClientContext* context, const ::p2r::TerminateCancel* request, ::p2r::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void P2rRestoreWarning(::grpc::ClientContext* context, const ::p2r::RestoreWarning* request, ::p2r::Response* response, std::function<void(::grpc::Status)>) override;
      void P2rRestoreWarning(::grpc::ClientContext* context, const ::p2r::RestoreWarning* request, ::p2r::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::p2r::Response>* AsyncP2rSetupConnectionRaw(::grpc::ClientContext* context, const ::p2r::SetupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::p2r::Response>* PrepareAsyncP2rSetupConnectionRaw(::grpc::ClientContext* context, const ::p2r::SetupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::p2r::Response>* AsyncP2rReleaseConnectionRaw(::grpc::ClientContext* context, const ::p2r::ReleaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::p2r::Response>* PrepareAsyncP2rReleaseConnectionRaw(::grpc::ClientContext* context, const ::p2r::ReleaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::p2r::Response>* AsyncP2rTerminateWarningRaw(::grpc::ClientContext* context, const ::p2r::TerminateWarning& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::p2r::Response>* PrepareAsyncP2rTerminateWarningRaw(::grpc::ClientContext* context, const ::p2r::TerminateWarning& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::p2r::Response>* AsyncP2rTerminateWarningCancelRaw(::grpc::ClientContext* context, const ::p2r::TerminateCancel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::p2r::Response>* PrepareAsyncP2rTerminateWarningCancelRaw(::grpc::ClientContext* context, const ::p2r::TerminateCancel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::p2r::Response>* AsyncP2rRestoreWarningRaw(::grpc::ClientContext* context, const ::p2r::RestoreWarning& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::p2r::Response>* PrepareAsyncP2rRestoreWarningRaw(::grpc::ClientContext* context, const ::p2r::RestoreWarning& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_P2rSetupConnection_;
    const ::grpc::internal::RpcMethod rpcmethod_P2rReleaseConnection_;
    const ::grpc::internal::RpcMethod rpcmethod_P2rTerminateWarning_;
    const ::grpc::internal::RpcMethod rpcmethod_P2rTerminateWarningCancel_;
    const ::grpc::internal::RpcMethod rpcmethod_P2rRestoreWarning_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status P2rSetupConnection(::grpc::ServerContext* context, const ::p2r::SetupRequest* request, ::p2r::Response* response);
    virtual ::grpc::Status P2rReleaseConnection(::grpc::ServerContext* context, const ::p2r::ReleaseRequest* request, ::p2r::Response* response);
    virtual ::grpc::Status P2rTerminateWarning(::grpc::ServerContext* context, const ::p2r::TerminateWarning* request, ::p2r::Response* response);
    virtual ::grpc::Status P2rTerminateWarningCancel(::grpc::ServerContext* context, const ::p2r::TerminateCancel* request, ::p2r::Response* response);
    virtual ::grpc::Status P2rRestoreWarning(::grpc::ServerContext* context, const ::p2r::RestoreWarning* request, ::p2r::Response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_P2rSetupConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_P2rSetupConnection() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_P2rSetupConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rSetupConnection(::grpc::ServerContext* /*context*/, const ::p2r::SetupRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2rSetupConnection(::grpc::ServerContext* context, ::p2r::SetupRequest* request, ::grpc::ServerAsyncResponseWriter< ::p2r::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_P2rReleaseConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_P2rReleaseConnection() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_P2rReleaseConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rReleaseConnection(::grpc::ServerContext* /*context*/, const ::p2r::ReleaseRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2rReleaseConnection(::grpc::ServerContext* context, ::p2r::ReleaseRequest* request, ::grpc::ServerAsyncResponseWriter< ::p2r::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_P2rTerminateWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_P2rTerminateWarning() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_P2rTerminateWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rTerminateWarning(::grpc::ServerContext* /*context*/, const ::p2r::TerminateWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2rTerminateWarning(::grpc::ServerContext* context, ::p2r::TerminateWarning* request, ::grpc::ServerAsyncResponseWriter< ::p2r::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_P2rTerminateWarningCancel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_P2rTerminateWarningCancel() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_P2rTerminateWarningCancel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rTerminateWarningCancel(::grpc::ServerContext* /*context*/, const ::p2r::TerminateCancel* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2rTerminateWarningCancel(::grpc::ServerContext* context, ::p2r::TerminateCancel* request, ::grpc::ServerAsyncResponseWriter< ::p2r::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_P2rRestoreWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_P2rRestoreWarning() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_P2rRestoreWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rRestoreWarning(::grpc::ServerContext* /*context*/, const ::p2r::RestoreWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2rRestoreWarning(::grpc::ServerContext* context, ::p2r::RestoreWarning* request, ::grpc::ServerAsyncResponseWriter< ::p2r::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_P2rSetupConnection<WithAsyncMethod_P2rReleaseConnection<WithAsyncMethod_P2rTerminateWarning<WithAsyncMethod_P2rTerminateWarningCancel<WithAsyncMethod_P2rRestoreWarning<Service > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_P2rSetupConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_P2rSetupConnection() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::p2r::SetupRequest, ::p2r::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::p2r::SetupRequest* request, ::p2r::Response* response) { return this->P2rSetupConnection(context, request, response); }));}
    void SetMessageAllocatorFor_P2rSetupConnection(
        ::grpc::MessageAllocator< ::p2r::SetupRequest, ::p2r::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::p2r::SetupRequest, ::p2r::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_P2rSetupConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rSetupConnection(::grpc::ServerContext* /*context*/, const ::p2r::SetupRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* P2rSetupConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::p2r::SetupRequest* /*request*/, ::p2r::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_P2rReleaseConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_P2rReleaseConnection() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::p2r::ReleaseRequest, ::p2r::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::p2r::ReleaseRequest* request, ::p2r::Response* response) { return this->P2rReleaseConnection(context, request, response); }));}
    void SetMessageAllocatorFor_P2rReleaseConnection(
        ::grpc::MessageAllocator< ::p2r::ReleaseRequest, ::p2r::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::p2r::ReleaseRequest, ::p2r::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_P2rReleaseConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rReleaseConnection(::grpc::ServerContext* /*context*/, const ::p2r::ReleaseRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* P2rReleaseConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::p2r::ReleaseRequest* /*request*/, ::p2r::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_P2rTerminateWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_P2rTerminateWarning() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::p2r::TerminateWarning, ::p2r::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::p2r::TerminateWarning* request, ::p2r::Response* response) { return this->P2rTerminateWarning(context, request, response); }));}
    void SetMessageAllocatorFor_P2rTerminateWarning(
        ::grpc::MessageAllocator< ::p2r::TerminateWarning, ::p2r::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::p2r::TerminateWarning, ::p2r::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_P2rTerminateWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rTerminateWarning(::grpc::ServerContext* /*context*/, const ::p2r::TerminateWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* P2rTerminateWarning(
      ::grpc::CallbackServerContext* /*context*/, const ::p2r::TerminateWarning* /*request*/, ::p2r::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_P2rTerminateWarningCancel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_P2rTerminateWarningCancel() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::p2r::TerminateCancel, ::p2r::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::p2r::TerminateCancel* request, ::p2r::Response* response) { return this->P2rTerminateWarningCancel(context, request, response); }));}
    void SetMessageAllocatorFor_P2rTerminateWarningCancel(
        ::grpc::MessageAllocator< ::p2r::TerminateCancel, ::p2r::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::p2r::TerminateCancel, ::p2r::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_P2rTerminateWarningCancel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rTerminateWarningCancel(::grpc::ServerContext* /*context*/, const ::p2r::TerminateCancel* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* P2rTerminateWarningCancel(
      ::grpc::CallbackServerContext* /*context*/, const ::p2r::TerminateCancel* /*request*/, ::p2r::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_P2rRestoreWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_P2rRestoreWarning() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::p2r::RestoreWarning, ::p2r::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::p2r::RestoreWarning* request, ::p2r::Response* response) { return this->P2rRestoreWarning(context, request, response); }));}
    void SetMessageAllocatorFor_P2rRestoreWarning(
        ::grpc::MessageAllocator< ::p2r::RestoreWarning, ::p2r::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::p2r::RestoreWarning, ::p2r::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_P2rRestoreWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rRestoreWarning(::grpc::ServerContext* /*context*/, const ::p2r::RestoreWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* P2rRestoreWarning(
      ::grpc::CallbackServerContext* /*context*/, const ::p2r::RestoreWarning* /*request*/, ::p2r::Response* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_P2rSetupConnection<WithCallbackMethod_P2rReleaseConnection<WithCallbackMethod_P2rTerminateWarning<WithCallbackMethod_P2rTerminateWarningCancel<WithCallbackMethod_P2rRestoreWarning<Service > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_P2rSetupConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_P2rSetupConnection() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_P2rSetupConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rSetupConnection(::grpc::ServerContext* /*context*/, const ::p2r::SetupRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_P2rReleaseConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_P2rReleaseConnection() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_P2rReleaseConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rReleaseConnection(::grpc::ServerContext* /*context*/, const ::p2r::ReleaseRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_P2rTerminateWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_P2rTerminateWarning() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_P2rTerminateWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rTerminateWarning(::grpc::ServerContext* /*context*/, const ::p2r::TerminateWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_P2rTerminateWarningCancel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_P2rTerminateWarningCancel() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_P2rTerminateWarningCancel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rTerminateWarningCancel(::grpc::ServerContext* /*context*/, const ::p2r::TerminateCancel* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_P2rRestoreWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_P2rRestoreWarning() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_P2rRestoreWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rRestoreWarning(::grpc::ServerContext* /*context*/, const ::p2r::RestoreWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_P2rSetupConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_P2rSetupConnection() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_P2rSetupConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rSetupConnection(::grpc::ServerContext* /*context*/, const ::p2r::SetupRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2rSetupConnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_P2rReleaseConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_P2rReleaseConnection() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_P2rReleaseConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rReleaseConnection(::grpc::ServerContext* /*context*/, const ::p2r::ReleaseRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2rReleaseConnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_P2rTerminateWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_P2rTerminateWarning() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_P2rTerminateWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rTerminateWarning(::grpc::ServerContext* /*context*/, const ::p2r::TerminateWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2rTerminateWarning(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_P2rTerminateWarningCancel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_P2rTerminateWarningCancel() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_P2rTerminateWarningCancel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rTerminateWarningCancel(::grpc::ServerContext* /*context*/, const ::p2r::TerminateCancel* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2rTerminateWarningCancel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_P2rRestoreWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_P2rRestoreWarning() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_P2rRestoreWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rRestoreWarning(::grpc::ServerContext* /*context*/, const ::p2r::RestoreWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2rRestoreWarning(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_P2rSetupConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_P2rSetupConnection() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->P2rSetupConnection(context, request, response); }));
    }
    ~WithRawCallbackMethod_P2rSetupConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rSetupConnection(::grpc::ServerContext* /*context*/, const ::p2r::SetupRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* P2rSetupConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_P2rReleaseConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_P2rReleaseConnection() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->P2rReleaseConnection(context, request, response); }));
    }
    ~WithRawCallbackMethod_P2rReleaseConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rReleaseConnection(::grpc::ServerContext* /*context*/, const ::p2r::ReleaseRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* P2rReleaseConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_P2rTerminateWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_P2rTerminateWarning() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->P2rTerminateWarning(context, request, response); }));
    }
    ~WithRawCallbackMethod_P2rTerminateWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rTerminateWarning(::grpc::ServerContext* /*context*/, const ::p2r::TerminateWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* P2rTerminateWarning(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_P2rTerminateWarningCancel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_P2rTerminateWarningCancel() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->P2rTerminateWarningCancel(context, request, response); }));
    }
    ~WithRawCallbackMethod_P2rTerminateWarningCancel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rTerminateWarningCancel(::grpc::ServerContext* /*context*/, const ::p2r::TerminateCancel* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* P2rTerminateWarningCancel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_P2rRestoreWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_P2rRestoreWarning() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->P2rRestoreWarning(context, request, response); }));
    }
    ~WithRawCallbackMethod_P2rRestoreWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2rRestoreWarning(::grpc::ServerContext* /*context*/, const ::p2r::RestoreWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* P2rRestoreWarning(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_P2rSetupConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_P2rSetupConnection() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::p2r::SetupRequest, ::p2r::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::p2r::SetupRequest, ::p2r::Response>* streamer) {
                       return this->StreamedP2rSetupConnection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_P2rSetupConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status P2rSetupConnection(::grpc::ServerContext* /*context*/, const ::p2r::SetupRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedP2rSetupConnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::p2r::SetupRequest,::p2r::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_P2rReleaseConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_P2rReleaseConnection() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::p2r::ReleaseRequest, ::p2r::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::p2r::ReleaseRequest, ::p2r::Response>* streamer) {
                       return this->StreamedP2rReleaseConnection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_P2rReleaseConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status P2rReleaseConnection(::grpc::ServerContext* /*context*/, const ::p2r::ReleaseRequest* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedP2rReleaseConnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::p2r::ReleaseRequest,::p2r::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_P2rTerminateWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_P2rTerminateWarning() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::p2r::TerminateWarning, ::p2r::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::p2r::TerminateWarning, ::p2r::Response>* streamer) {
                       return this->StreamedP2rTerminateWarning(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_P2rTerminateWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status P2rTerminateWarning(::grpc::ServerContext* /*context*/, const ::p2r::TerminateWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedP2rTerminateWarning(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::p2r::TerminateWarning,::p2r::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_P2rTerminateWarningCancel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_P2rTerminateWarningCancel() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::p2r::TerminateCancel, ::p2r::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::p2r::TerminateCancel, ::p2r::Response>* streamer) {
                       return this->StreamedP2rTerminateWarningCancel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_P2rTerminateWarningCancel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status P2rTerminateWarningCancel(::grpc::ServerContext* /*context*/, const ::p2r::TerminateCancel* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedP2rTerminateWarningCancel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::p2r::TerminateCancel,::p2r::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_P2rRestoreWarning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_P2rRestoreWarning() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::p2r::RestoreWarning, ::p2r::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::p2r::RestoreWarning, ::p2r::Response>* streamer) {
                       return this->StreamedP2rRestoreWarning(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_P2rRestoreWarning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status P2rRestoreWarning(::grpc::ServerContext* /*context*/, const ::p2r::RestoreWarning* /*request*/, ::p2r::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedP2rRestoreWarning(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::p2r::RestoreWarning,::p2r::Response>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_P2rSetupConnection<WithStreamedUnaryMethod_P2rReleaseConnection<WithStreamedUnaryMethod_P2rTerminateWarning<WithStreamedUnaryMethod_P2rTerminateWarningCancel<WithStreamedUnaryMethod_P2rRestoreWarning<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_P2rSetupConnection<WithStreamedUnaryMethod_P2rReleaseConnection<WithStreamedUnaryMethod_P2rTerminateWarning<WithStreamedUnaryMethod_P2rTerminateWarningCancel<WithStreamedUnaryMethod_P2rRestoreWarning<Service > > > > > StreamedService;
};

}  // namespace p2r


#endif  // GRPC_P2r_2eproto__INCLUDED
